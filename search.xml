<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[wsgi简介]]></title>
    <url>%2F2019%2F02%2F22%2Fwsgi%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[wsgi是什么？WSGI：Web Server Gateway Interface。WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。 创建一个读取时间的py文件传入两个参数，一个env，一个报头，根据解析出来的env，作出不同的处理。 123456789101112#-*- conding:utf-8 -*-import timedef applitation(env,start_response): # env.get(&quot;Method&quot;) # env.get(&quot;Path_Info&quot;) # states = &quot;200 OK&quot; headers = &#123; (&quot;Content-Type&quot;,&quot;text/plain&quot;) &#125; start_response(states,headers) return time.ctime() 编写回调函数,回调函数一般没有返回值，用self方法直接实现更新 1234567891011def start_response(self,status,headers): &apos;&apos;&apos; states = &quot;200 OK&quot;headers = &#123; (&quot;Content-Type&quot;,&quot;text/plain&quot;)&#125; &apos;&apos;&apos; response_headers = &quot;HTTP/1.1 &quot; + status +&quot;\r\n&quot; for head in headers: response_headers += &quot;%s: %s\r\n&quot;%head self.response_headers =response_headers #作用 可以方便功能扩展 sys进行默认文件夹填充 1sys.path.insert(1,WSGI_PYTHON_DIR) 自调用 1def __call__(self) 服务器和框架示意图]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>http</tag>
        <tag>wsgi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一个简单的WEB框架]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84WEB%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[前面都是从httpserver中添加功能，下面希望把添加web功能写成框架的形式，如果进行开发，只需要响应的功能模块就行，而不是在httpserver中改写。 #想要实现的功能外部调用，外部功能更新12345678910urls=[ (&quot;/&quot;,show_ctime), (&quot;/ctime&quot;,show_ctime), (&quot;/sayhello&quot;,say_hello) ] app = Applittation(urls) http_server = HTTPServer(app) http_server.bind(8000) http_server.start() #创建一个通用框架的类1234567891011121314151617class Applittation(object): &apos;&apos;&apos;框架的核心部分，框架的主题程序&apos;&apos;&apos; def __init__(self,urls): self.urls = urls def __call__(self, env, start_response): path = env.get(&quot;PATH_INFO&quot;,&quot;/&quot;) print(path) for url,handler in self.urls: if path == url: print(handler) return handler(env,start_response) #代表未找到路由信息404错误 status =&quot;404 Not Found&quot; headers =[] start_response(status,headers) return &quot;not found&quot; #外部随便编写几个功能模块12345678910111213141516def show_ctime(env,start_response): states = &quot;200 OK&quot; headers = &#123; (&quot;Content-Type&quot;, &quot;text/plain&quot;) &#125; start_response(states, headers) return time.ctime()def say_hello(env,start_response): states = &quot;200 OK&quot; headers = &#123; (&quot;Content-Type&quot;, &quot;text/plain&quot;) &#125; start_response(states, headers) return &quot;say hello&quot; 精简服务模块传入框架app模块12345def __init__(self,application): &apos;&apos;&apos;构造函数application指的是框架的app&apos;&apos;&apos; self.serves_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM) self.serves_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.app = application 总结 用回调函数，对类直接进行调用 1def __call__(self, env, start_response): 把功能进行路由分发 12path = env.get(&quot;PATH_INFO&quot;,&quot;/&quot;) print(path) 结果 启动更新，通过服务器启动程序 直接通过app对象调用框架里面的urls 1234567urls = [ (&quot;/&quot;, show_ctime), (&quot;/ctime&quot;, show_ctime), (&quot;/sayhello&quot;, say_hello)]app = Applittation(urls) 启动设置 1234567891011ef main(): sys.path.insert(1,WSGI_PYTHON_DIR) #启动方式 python MyServer.py MyWebFramework:app if len(sys.argv)&lt;2: sys.exit(&quot;python mywebserver.py mpdule:app&quot;) module_name, app_name = sys.argv[1].split(&quot;:&quot;) m = __import__(module_name) app = getattr(m,app_name) http_server = HTTPServer(app) http_server.bind(8000) http_server.start()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>http</tag>
        <tag>python</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器上布置python接口]]></title>
    <url>%2F2019%2F02%2F22%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%B8%83%E7%BD%AEpython%E9%97%AE%E7%AD%94%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1.在本机上试运行用flask布置本地访问和返回123456789@app.route(&apos;/&apos;, methods=[&apos;POST&apos;, &apos;GET&apos;])def get_text_input(): # 如果遇到显示问题：下载QQ浏览器，将编码设置为utf-8 text = request.args.get(&apos;inputStr&apos;) print(text) return aiqa(text)if __name__ == &quot;__main__&quot;:# # 这种是不太推荐的启动方式，我这只是做演示用，官方启动方式参见：http://flask.pocoo.org/docs/0.12/quickstart/#a-minimal-application app.run(host=&apos;0.0.0.0&apos;,debug=True) 结果：2.布置到服务器上面查看本机运行环境1python -m pip list 配置服务器环境123pip3 install py2neo==3.1.2pip3 install jieba==0.39pip3 install flask==0.11.1 3.把访问的端口改成本地的IP，其他服务器可以进行访问1app.run(host=&apos;0.0.0.0&apos;,port=50001,debug=True) 4.遇到的问题 本地端口被占用解决办法：1234567891011121314151617181920212223查看已经连接的服务端口（ESTABLISHED）netstat -a查看所有的服务端口（LISTEN，ESTABLISHED）netstat -ap查看指定端口，可以结合grep命令：netstat -ap | grep 8080 也可以使用lsof命令：lsof -i:8888若要关闭使用这个端口的程序，使用kill + 对应的pidkill -9 PID号查看端口netstat -ap | grep 50001结果：tcp 0 0 0.0.0.0:50001 *:* LISTEN 43887/python3 终结端口：1kill -9 43887 python3编码问题1UnicodeEncodeError &apos;ascii&apos; codec can&apos;t encode characters in position 0-1 原因分析：https://blog.csdn.net/TH_NUM/article/details/80450607解决办法：运行代码时候前面加上：1PYTHONIOENCODING=utf-8 python your_script.py ajax请求flask需要添加跨域请求12345678app = Flask(__name__)# 跨域支持def after_request(resp): resp.headers[&apos;Access-Control-Allow-Origin&apos;] = &apos;*&apos; return respapp.after_request(after_request) 网址：https://blog.zengrong.net/post/2615.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>http</tag>
        <tag>服务器</tag>
        <tag>python3</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用socket进行网络通信]]></title>
    <url>%2F2019%2F02%2F22%2F%E7%94%A8socket%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[建立tcp传输123serves_socket = socket.socket(family=socket.AF_INET,type=socket.SOCK_STREAM)serves_socket.bind((&quot;&quot;,8000))serves_socket.listen(128) #建立多线程访问123456while True: cli_socket, cli_address = serves_socket.accept() print(&quot;[%s %s]客户连接上了&quot;% cli_address) handale_client_socket = Process(target=handle_client,args=(cli_socket,)) handale_client_socket.start() cli_socket.close() #处理客户端请求以及生成HTTP报头123456789101112131415161718def handle_client(cli_socket): &apos;&apos;&apos;处理客户端请求&apos;&apos;&apos; # 获取客户端请求数据 request_data = cli_socket.recv(1024) print(request_data) #构造响应数据 reponse_start_line = &quot;HTTP/1.1 200 ok\r\n&quot; reponse_headers = &quot;Server: myserves\r\n&quot; reponse_body = &quot;hello world&quot; reponse = reponse_start_line+reponse_headers+&quot;\r\n&quot;+reponse_body print(reponse) #向客户端返回响应数据 cli_socket.send(bytes(reponse,&quot;utf-8&quot;)) #关闭客户端连接 cli_socket.close() 一个简单的链接搭建完成了访问http://127.0.0.2:8000/结果：1hello world 访问静态文件 进行同一个接口重复访问设置 1serves_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) 对2进制文件进行utf-8解码 1234567891011121314151617181920#解析报文 GET / HTTP/1.1 request_lines = request_data.splitlines() request_start_line = request_lines[0] file_name = re.match(r&apos;\w+ +(/[^ ]*)&apos;,request_start_line.decode(&quot;utf-8&quot;)).group(1) if &quot;/&quot;==file_name: file_name=&quot;/index.html&quot; try: with open(HTML_ROOT_DIR + file_name,&quot;rb&quot;) as f: file_data = f.read() except IOError: reponse_start_line = &quot;HTTP/1.1 404 Not Found\r\n&quot; reponse_headers = &quot;Server: myserves\r\n&quot; reponse_body = &quot;文件找不到&quot; else: #构造响应数据 reponse_start_line = &quot;HTTP/1.1 200 ok\r\n&quot; reponse_headers = &quot;Server: myserves\r\n&quot; reponse_body = file_data.decode(&quot;utf-8&quot;) reponse = reponse_start_line+reponse_headers+&quot;\r\n&quot;+reponse_body print(reponse)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>http</tag>
        <tag>python</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识图谱问答系统]]></title>
    <url>%2F2019%2F02%2F22%2F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[优秀的问答系统有两个关键点：精确的问题理解和高质量的知识来源。 问题理解由于问题的多样性和复杂性，很难人工制定一套规则完成问题理解。因此从数据中进行问题语义学习是必要的。社交类问答网站的兴起，包括Yahoo! Answers，Stack Overflow，百度知道等。由用户在上面进行提问和回答。这些网站包含了大量的问答对数据集，这成为了问题理解的优质语料。海量的问答语料为问题理解的学习提供了数据基础。 知识来源由于知识表述的多样性，以及知识关联的复杂性，需要优质而大量的知识来源。近年来，一批高准确率、海量规模的知识图谱涌现，为问答系统提供了结构化、关联化的知识来源。这也为高效的问题回答提供了知识基础。 如何设定恰当模型学习并使用这一批数据就显得尤为重要。传统的基于规则的模型 无法合理利用海量语料；基于关键词的模型 ，则没有进行深入的语义理解。而一些复杂的图模型等 ，则由于时间复杂度很难直接应用在如此大规模的语料中。本文的研究，即旨在寻求一种优秀的、系统性的问答系统表示和学习模型，并进行成功应用。 2011 年的 Science 曾经以“互联” 为题，出版专刊阐述了一个基本观点：我们身处在一个“互联”的时代。各种网络,诸如互联网、物联网、社会网络、语义网络、生物网络等等，将各类实体、概念加以互联。网络已经成为刻画复杂性的基本形态。管理、理解和使用各种网络数据，包括知识图谱，已经成为征服复杂性的基本手段。 知识图谱具有明显格式化特征，其值往往是一个实体名字或者一个数字、一个日期。这保证了基于知识图谱的问答系统的回答简洁性。另一方面，不同于基于信息检索的问答系统需要考虑数据真实性的问题，知识图谱的高数据质量保证了答案的准确性。1.2优势基于知识图谱的问答系统，需要解决两个核心问题：（1）如何理解问题语义，并用计算机可以接受的形式进行表示（问题的理解和表示）；（2）以及如何将该问题表示关联到知识图谱的结构化查询中（语义关联）。 问题理解和表示：知识图谱中有数以千计的关系，而一种关系可以有数以千计的问法。例如，表 1.1 中的问题 ○a 和问题 ○b 都询问了檀香山市的人口，尽管它们的表达方式大相径庭。对于不同的问题形式，问答系统使用不同的表示方法。这些问题表示必须满足（1）归一具有相同语义的问题；（2）区分不同意图的问题。 所使用的问答语料库最终找到了 2782 种问题意图的约 2700 万种问题形式。所以问题表示形式设计就是一个巨大的挑战。 语义关联：在获取一个问题的表现示之后，系统需要将这一表现示映射为结构化查询。结构化查询主要依赖于知识库中的属性。由于属性和表现模型之间的跨越，寻找这样的匹配并非直接。例如，在表 1.1 中，系统需要知道问题 ○a 与属性 population 有着相同的语义。此外，在 RDF 图中，许多二元关系并不仅仅对应一条边，而是某种复杂的结构：在图 1.1 中，“配偶”关系由 marriage → person → name 的路径表示。对于本文使用的知识库，超过 98% 的关系对应于类似的复杂结构。 第 2 节 研究架构与模块关联一般性和特殊性的取舍问题 本节试着问答问题：“什么样的动词模板可以很好的总结一个动词短语集合”。由于每个动词短语都有若干候选动词模板，这个问题的回答是很困难的。直觉上，一个好的动词模板需要兼备一般性和特殊性。 一般性：本章希望用较少的模板个数来覆盖一个动词的所有语义。否则，抽取出的动词模板会变得琐碎。考虑极端的情况：所有的动词短语都被考虑为俗语模板。这些俗语模板显然大部分都是没意义的，因为大部分动词短语需要被概念化。 例 4.2. 在图 4.1 中,模（eat $Cmeal）显然比三个模板（eat $Ibreakfast + eat $Ilunch+eat $Idinner）要好。前者提供了一个更一般的模板表示。 本章的贡献可以被总结如下： 本章提出了动词模板——一种新型的动词语义表现形式。本章提出了两类动词模板:概念化模板和俗语模板。动词模板可以表示动词的歧义性,因此可以用来识别动词的不同语义。 本章提出了关于动词模板抽取的两个原则:一般性和特殊性原则。本章阐述了这两个原则间的互相制约,并提出了一个基于最小描述长度的无监督模型来产生高质量动词模板。 本章进行了多样的实验。其结果证实了模型和算法的有效性。 利用了动词模板后，精确度都显著的被提高了。这表明了动词模板对于语义理解任务是有意义的。]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>知识表示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络通信]]></title>
    <url>%2F2019%2F02%2F22%2F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[#网络通信的四个层级 深度理解socket1.他是一个网络通信的工具，调用操作系统内核创建的时候，可以选择tcp通讯，“三次握手，四次挥手”，也可以选择udp通信，一次通信 2.socket解决的是应用层下的 #应用层解决的是什么你传输的是什么内容，例如： ftp传输的是文件； ssh传输的是命令远程连接。 smtp和pop3邮件传输， 使用最多的是HHTP协议#从传输文本到html协议只传输文本的话，文本结构效果不理想，需要进行结构化的数据，存文本不利于展示。对文本进行包装，就是html语言： 假如对浏览器进行交互，就要引入javascript进行前端交互。浏览器也会增加一个JavaScript的解析器。把解析JavaScript抽出来，甚至作为后端就是node.js。 #HTTP协议超文本传输协议，浏览器就是起到一个客户端的作用。http状态码http://tool.oschina.net/commons?type=5 #服务器开发的工作 解决解析客户端发过来的报文 支持很多进行访问多线程#参数传递 url后面的？带参数]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>http</tag>
      </tags>
  </entry>
</search>
